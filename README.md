<!--
 * @Author: makospace 1505548152@qq.com
 * @Date: 2024-07-25 12:04:46
 * @LastEditors: makospace 1505548152@qq.com
 * @LastEditTime: 2024-07-25 12:08:11
 * @FilePath: \ZZKernel\README.md
 * @Description: 
 * 
 * Copyright (c) 2024 by ${git_name_email}, All Rights Reserved. 
 * for test
 * hello test1
-->
# ZeroOS
搭建一个小型操作系统内核需要一定的编程基础和对计算机系统的理解。以下是一个分步骤的实现方法：
<!-- 一个测试 -->
1. 准备工具和环境：
   - 安装一个C编译器，如GCC
   - 安装汇编编译器，如NASM
   - 安装QEMU虚拟机
   - 准备一个文本编辑器，如Visual Studio Code

2. 编写Bootloader：
   - 使用汇编语言编写一个简单的Bootloader，它的主要任务是将操作系统内核从磁盘加载到内存中，并跳转到内核的入口点执行。
   - 编译Bootloader为二进制文件，并使用dd命令将其写入引导扇区。

3. 编写操作系统内核：
   - 使用C语言编写内核的主要部分，包括内核的入口点、初始化硬件、设置中断向量表等。
   - 编写内核的Makefile，用于编译内核并生成内核映像文件。

4. 文件管理：
   - 参考FAT文件系统，实现底层的磁盘读写操作。
   - 实现inode和目录表的数据结构和相关操作。
   - 提供文件操作API，如打开、关闭、读取、写入等。

5. 内存管理：
   - 设计内存分配和回收算法，如buddy system或slab allocator。
   - 实现内存管理的API，如malloc、free等。
   - 实现内存轮调算法，如最近最少使用（LRU）算法。

6. 进程管理：
   - 设计进程控制块（PCB）数据结构，用于存储进程的状态、优先级等信息。
   - 实现进程调度算法，如轮转法（Round Robin）或优先级调度。
   - 实现死锁处理和互斥控制，如银行家算法和信号量。

7. 中断处理：
   - 编写中断服务程序（ISR），用于处理不同类型的中断，如时钟中断、键盘中断等。
   - 在内核初始化时，设置中断向量表，将中断服务程序与相应的中断向量关联。

8. 部署到QEMU虚拟机：
   - 将Bootloader和内核映像文件合并为一个磁盘映像文件。
   - 使用QEMU虚拟机启动磁盘映像文件，观察操作系统内核的运行情况。

这个过程需要不断地调试和优化。在实际操作中，你可能需要参考更多的资料和示例代码。建议你阅读一些操作系统教程和开源项目，如《操作系统真象还原》和Xv6操作系统。

## 具体实现
1. 开始：CS:0xf000, IP:0xfff0，这里存放着BIOS的入口地址，此处只有一条16B的跳转指令，将IP变为0xe05b，进入BIOS基本输入输出系统区，有三个功能（进行硬件自启动检查，进行中断向量表的设置，跳转到MBR（Main Boot Recoder）主引导扇区，IP变为0x7c00，这是历史遗留问题（以前的空间大小的限制），MBR是第0磁道，第0盘，第0扇区的块（512B），最后两个字节是0x55,0xaa,要是不是就继续往后面找，MBR的作用是将操作系统Loader加载进来，然后跳转到对应位置（因为512字节太小，不足以调入操作系统，后面还可以如此进行多次跳转，直到加载完所有操作系统未知，之所以第一次跳不做任务，是因为这是历史遗留问题，默认MRB在0x7c00

2. loader是可以跨越一个扇区的，所以复杂的操作系统就由loader调入，loader里的GDT暂时取代了段表的地位（global description table），kernel才是最终的内核，实现了中断，内存管理，分配等的所有操作，需要完全通过loader载入内存，**loader是将kernel.bin加载进入内存，然后解析elf文件头完成内核镜像的创建，然后loader（jmp KERNEL_ENTRY_POINT指令）跳转进入内核镜像执行；**

3. 其实这不是完整的自我实现操作系统，否则一开始的编译成二进制或者使用的c代码，都是需要调用底层函数的，但其实这时候操作系统还没有完成，是用宿主机完成的

4. 不断编写elf文件（就是汇编代码，然后编译为elf），然后使用dd存入kernel，再次loader就可以把后面新加的kernel一起加载入内存，比如我编写了print函数（汇编），然后可以使用c语言包含对应头文件，就可以使用自己编写的底层函数了，在自己的虚拟机上是无法使用任何C的函数的，因为其对应的底层汇编函数没有实现，如果实现的非常完备，就像Linux一样，就可以使用其开发新的编程语言，这就是为什么新语言通常要在Linux下开发，可以使用已经有的底层汇编函数，自己新加一些汇编函数也会变得简单
5. 出现中断，到最后找到中断处理程序的入口，这个过程需要硬件配合。当出现中断的时候，硬件会为这个中断分配一个中断号码。然后硬件拿着这个号码，去查找IDT表，找到对应的中断门描述符。从中断门描述符中取出要执行的中断处理程序的cs选择子，与ip偏移。有了cs与ip，硬件自然就能够跳转执行对应的中断处理程序。而我们要做的，就是准备IDT表，准备中断处理程序。然后在IDT表中断对应的中断门描述符中填入中断处理程序的地址。最后将IDT表的地址加载进入IDTR，这样硬件才能找到IDT表，找到中断门描述符，进而找到中断处理程序。kernel.S只是用来存储中断处理程序的文件罢了，中断处理程序的地址已经被填入IDT表对应的中断门描述符中了。
6. keyboard和cursor中断是外部中断，需要单独配置，同样的需要编写中断处理函数和中断向量表，注意的是，键盘中断按一下会触发两次，这里忽略掉弹起操作
7. 我们不必在kernel.S中直接定义对应的函数比如fork，而是可以给出一个指向，当要执行kernel中的fork时，跳转到对应的代码区（可以使用C来写），就是汇编来调call C，在C中修改的操作，其实就是为了返回或者完善某个数据结构，只要我在汇编里找到这个结构就可以，可以使用extern直接获取call C修改后的数据结构，当然extern是在开始时就执行的，是一个全局结构，汇编call汇编函数，不用push，因为是自带的，但是callC函数，要push pop保护恢复现场，call [id_table + %1 * 4], id_table里存的是一个字符串，是函数名
8. 那为什么可以直接使用汇编呢，其中的寄存器又是怎么和底层对应的呢，这就直接是QEMU的功能了，它是一种免费的开源硬件虚拟化软件，可以模拟多种硬件架构并运行不同操作系统的应用程序。它可以在宿主计算机的不同操作系统上运行，例如Linux、Windows、Mac OS等。QEMU支持许多处理器架构，如x86，ARM，MIPS等。至于可以不可以自己写一个QEMU，这就是硬件工程师的任务了，需要封装底层布线逻辑，给每个寄存器命名和赋予意义，处理时钟频率等
9. 任何文件在本地存储为二进制，分为数据和属性两部分，包括图片
10. 每个进程都有各自独立的虚拟存储空间，但是共用的是一个实际地址空间，所以需要有一个全局物理位图，修改物理位图需要原子操作（用开关中断完成），物理内存只有32M，虚拟内存有4GB(2^32)
11. 页目录表有对应的寄存器，就像磁盘地址对应的寄存器一样，找到对应的页目录表寄存器，找到对应基地址（二级表）
12. malloc分配地址空间时，需要两个区域的分配，一是虚地址的分配，二是实地址的分配，如果page_table没有对应的实际地址，就需要新加一条记录来记录此映射关系，当然首先需要创建一个page_table表，记录虚地址和实际地址的映射关系，同时将全局位图引入，避免进程之间互相干扰，分配时需要传入一个bool值，判断当前是user还是kernel在申请，对于kernel，有一个特殊划出的固定区域，且不允许为满，这是为了处理应急情况
## 自问自答
### 问题
1. kernel.S中不必存放对应函数的汇编代码，而是直接call用C写的函数，那这个C文件是在什么时候被调入内存的，是在加载loader时吗
2. loader是边执行边把kernel调入内存吗，还是执行完loader之后直接到下次一个磁盘调入kernel
3. CPU是怎么由二进制地址找到对应的扇区的，因为二者的地址表示方式并不相同
4. C语言和汇编为什么可以直接在还未完善的操作系统上运行
5. 操作系统本质是一个死循环，这个在代码的哪里有体现
6. 中断的流程
7. BIOS存在哪里
8. loader是自己写的吗
9. kernel是用不同语言写的，那怎么发挥作用呢
### 回答
1. C函数的代码和内核链接在了一起，你加载内核（kernel.bin）的时候，就把C函数中的中断处理函数一起加载到了内存中；2
2. 不明白你这个问题中的kernel是指kernel.bin还是kernel.S编译之后的kernel.o。kernel.o已经被链接（ld命令）进入kernle.bin文件中了，loader是将kernel.bin加载进入内存，然后解析elf文件头完成内核镜像的创建，然后loader（jmp KERNEL_ENTRY_POINT指令）跳转进入内核镜像执行；
3. cpu并不会自己找到扇区，而是我们人为与磁盘暴露在外的寄存器打交道，告知磁盘我们要读哪个扇区，要读多少，然后我们自己去磁盘对应的寄存器取数据；cpu在这个过程中，只是在执行我们的指令
4. c语言和汇编语言最终都是翻译成二进制代码，自然都能在机器上运行，可以不需要操作系统参与，就能够直接执行，所以不需要操作系统是否完善。
5. 操作系统的死循环特性，在后面代码才有体现。换个角度理解，现代操作系统windows，linux，都是在不断等待用户产生行为（如打开软件，运行软件），然后去执行用户要求的任务，完了之后，又继续等待用户产生新的行为，这就是个循环。】
6. [cnblogs](https://www.cnblogs.com/wkfvawl/p/10957080.html)
7. BIOS是一组固化到计算机内主板上一个ROM（Read-Only Memory）只读存储器中的程序，不需要供电就可保持数据不丢失。因此，BIOS最是存储在主板上的ROM芯片中，而不是磁盘或内存中。当计算机启动时，BIOS会被加载到内存中，并执行自检程序和系统启动自检程序。ROM（Read-Only Memory）是只读存储器，它是一种存储数据的硬件设备，与内存不同。内存是一种易失性存储器，需要电源供电才能保持数据，而ROM是一种非易失性存储器，不需要电源供电就可以保持数据不丢失。ROM中的数据是在制造时被写入的，一旦写入就无法修改，因此被称为只读存储器。在计算机中，BIOS程序通常存储在ROM芯片中，以便在计算机启动时被加载到内存中执行。（ROM不是内存）
8. 依照简化的Grub，有现成的代码
9. 使用ld（一种连接器），将汇编生成的.o文件和C生成的.o文件连接在一起，生成.bin文件

## 技术
- shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。shell 的主要结构很简单，详见 main 的代码（8001）。主循环通过 getcmd 读取命令行的输入，然后它调用 fork 生成一个 shell 进程的副本。父 shell 调用 wait，而子进程执行用户命令（即调用对应输入代表函数名的命令的函数）
- 系统调用 exec 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。
- 每个进程都有一个从0开始的文件描述符空间
## 参考
- (xv6操作系统)[https://github.com/ranxian/xv6-chinese/blob/master/content/]